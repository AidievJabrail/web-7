{"ast":null,"code":"import _classPrivateFieldLooseBase from\"/home/jabrail/Labs/Lab7/web-7/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js\";import _classPrivateFieldLooseKey from\"/home/jabrail/Labs/Lab7/web-7/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js\";import{Component}from'react';// Импорт другой компоненты\nimport{Deletable}from'../../widgets/Deletable/Deletable';// Импорт файла со стилями\nimport'./style.css';// Страничка туду\nimport{jsx as _jsx,jsxs as _jsxs}from\"react/jsx-runtime\";var _handleCompletedChange=/*#__PURE__*/_classPrivateFieldLooseKey(\"handleCompletedChange\");var _handlerTodoDelete=/*#__PURE__*/_classPrivateFieldLooseKey(\"handlerTodoDelete\");export class TodoPage extends Component{constructor(props){super(props);// Инициализируем состояние страницы\nObject.defineProperty(this,_handlerTodoDelete,{value:_handlerTodoDelete2});Object.defineProperty(this,_handleCompletedChange,{value:_handleCompletedChange2});// Биндим контекст this. Вынесли bind за пределы метода render, чтобы не пересоздавать\n// объект функции с привязанным контекстом для каждой todo из массива. Такой подход передачи\n// пропсов так же является правильным и с точки зрения оптимизаций react\n// Подробнее про key-проп https://www.youtube.com/watch?v=OtAlPwW8DNU&t=409s\nthis.delete=_classPrivateFieldLooseBase(this,_handlerTodoDelete)[_handlerTodoDelete].bind(this);this.state={// Массив тудушек\ntodos:[],// Флаг, указывающий, что идет процесс загрузки данных\nisLoading:true};}// Метод жизненного цикла, который вызывается один раз для компоненты после ее вмонтирования\ncomponentDidMount(){// Асинхронный вызов получения данных тудушек. Возвращает объект Promise, для которого\n// в случае успешного завершения запроса вызовется обработчик переданный в метод then\nfetch('https://jsonplaceholder.typicode.com/todos')// Вызов обработчика, который парсит тело ответа. Так как метод json является асинхронным (возвращает Promise),\n// для него необходимо определить обработчик с помощью повторного вызова метода then\n.then(response=>response.json())// Стрелочная функция на вход принимает уже обработанное тело ответа\n.then(todos=>{// Обновляем состояние страницы\nthis.setState({todos:todos,// Сбрасываем флаг из loading\nisLoading:false});})// Обработчик на тот случай, если асинхронный вызов по каким-то причином завершился с ошибкой,\n// например, сервер не доступен\n.catch(()=>{console.log('Произошла ошибка');});}render(){return/*#__PURE__*/_jsxs(\"div\",{className:\"todo-page\",children:[/*#__PURE__*/_jsx(\"h2\",{children:\"Todo page\"}),this.state.isLoading&&/*#__PURE__*/_jsx(\"div\",{className:\"loader\",children:\"\\u0417\\u0430\\u0433\\u0440\\u0443\\u0437\\u043A\\u0430...\"})||// Метод map позволяет перебрать массив, и на ее основе сформировать новый массив\n// В данном случае формируем массив JSX-объектов. Метод map принимает функцию-обработчик,\n// которая принимает очередной элемент и индекс этого элемента \nthis.state.todos.map((todo,index)=>{return(/*#__PURE__*/// Компонента, которая добавляет элементу todo функционал удаления.\n// Внутрь JSX-объекта можно передать другой JSX-объект или список объектов.\n// Эти объекты будут записаны в props.children\n_jsx(Deletable,{title:todo.title,id:todo.id// Передаем обработчик удаления\n,deleteHandler:this.delete// Подробнее про key-проп https://www.youtube.com/watch?v=OtAlPwW8DNU&t=409s\n,children:/*#__PURE__*/_jsxs(\"div\",{className:\"todo\",children:[/*#__PURE__*/_jsx(\"input\",{type:\"checkbox\"// Осуществляем контроль отображения компоненты\n,checked:todo.completed,onChange:_classPrivateFieldLooseBase(this,_handleCompletedChange)[_handleCompletedChange].bind(this,index)// В завимисоти от состояния меняет CSS-стили\n}),\" \",/*#__PURE__*/_jsx(\"span\",{style:{color:todo.completed?'green':'red'},children:todo.title})]})},todo.id));})]});}}function _handleCompletedChange2(index){// Документация реакт по обновлению состояния списка https://react.dev/learn/updating-arrays-in-state\n// Правильное обновление состояния сложных объект подразумевает, что мы должны изменить ссылку на сложный\n// объект, иначе могут возникнуть различные проблемы с перерисовкой приложения. Обычно react-разработчики стараются\n// оптимизировать количество перерисовок компонент, сравнивая предыдущие и текущие пропсы. Сравнение объектов в JS\n// является поверхностным, то есть он сравнивает только ссылки на равенство. Если мы напрямую будем мутировать this.state.todos,\n// и, например, у нас бы была оптимизированная компонента TodosList, которая на вход принимала бы массив todos, то приложение бы не обновлялось,\n// даже если бы мы изменили хотя бы один объект в массиве. Но ссылка на сходный массив не изменилась, поэтому перерисовки интефейса не произойдет\n// Правильным подходом является создание нового массива на основе данных сещствующего массива. Массивы в JS хранят ссылки на объекты.\n// Вызов метода slice позволит создать новый массив на основе старого, путем копирования ссылок на объекты, то есть копирование здесь поверхностное,\n// но с точки зрения работы с состоянием реакта мы все сделали правильно, поскольку мы не изменяем исходный объект, а создаем на его основе новый\n// Такая здесь парадигма :)\n// Очень хороший видеоролик, который показывает как правильно работать со сложным состоянием: https://www.youtube.com/watch?v=a2DkRBnp4ns\n// Так же новые объекты массива создают методы map и filter. Их тоже можно использовать для создания нового объекта массива\n// (в зависимости от задачи: отфильтровать массив или на основе существующего массива обработать каждый элемент и получить новый массив)\nconst updatedTodos=this.state.todos.slice();// Здесь так же приведен объект, как правильно создавать новый объект на основе существующего.\n// \"...\" это spread-оператор или деструктуризация, которая позволяет разложить все свойства объекта и на их основе сконструировать новый объект.\n// Порядок при этом важен. ```completed: !updatedTodos[index].completed``` должно идти позже spread, иначе для нового объекта todo свойство completed\n// будет взято из старого объекта\nupdatedTodos[index]={...updatedTodos[index],completed:!updatedTodos[index].completed};this.setState({todos:updatedTodos});}function _handlerTodoDelete2(id){// Реализуем удаление элемента с помощью метода filter, который возвращает новый массив, состоящий из элементов,\n// прошедших фильтрацию\nconst updatedTodos=this.state.todos.filter(todo=>{return todo.id!==id;});this.setState({todos:updatedTodos});}","map":{"version":3,"names":["Component","Deletable","jsx","_jsx","jsxs","_jsxs","_handleCompletedChange","_classPrivateFieldLooseKey","_handlerTodoDelete","TodoPage","constructor","props","Object","defineProperty","value","_handlerTodoDelete2","_handleCompletedChange2","delete","_classPrivateFieldLooseBase","bind","state","todos","isLoading","componentDidMount","fetch","then","response","json","setState","catch","console","log","render","className","children","map","todo","index","title","id","deleteHandler","type","checked","completed","onChange","style","color","updatedTodos","slice","filter"],"sources":["/home/jabrail/Labs/Lab7/web-7/src/pages/TodoPage/TodoPage.jsx"],"sourcesContent":["import { Component } from 'react'\n\n// Импорт другой компоненты\nimport { Deletable } from '../../widgets/Deletable/Deletable';\n\n// Импорт файла со стилями\nimport './style.css'\n\n// Страничка туду\nexport class TodoPage extends Component {\n    constructor(props) {\n        super(props);\n\n        // Инициализируем состояние страницы\n        this.state = {\n            // Массив тудушек\n            todos: [],\n\n            // Флаг, указывающий, что идет процесс загрузки данных\n            isLoading: true\n        };\n    }\n\n    // Биндим контекст this. Вынесли bind за пределы метода render, чтобы не пересоздавать\n    // объект функции с привязанным контекстом для каждой todo из массива. Такой подход передачи\n    // пропсов так же является правильным и с точки зрения оптимизаций react\n    // Подробнее про key-проп https://www.youtube.com/watch?v=OtAlPwW8DNU&t=409s\n    delete = this.#handlerTodoDelete.bind(this)\n\n    // Метод жизненного цикла, который вызывается один раз для компоненты после ее вмонтирования\n    componentDidMount() {\n        // Асинхронный вызов получения данных тудушек. Возвращает объект Promise, для которого\n        // в случае успешного завершения запроса вызовется обработчик переданный в метод then\n        fetch('https://jsonplaceholder.typicode.com/todos')\n            // Вызов обработчика, который парсит тело ответа. Так как метод json является асинхронным (возвращает Promise),\n            // для него необходимо определить обработчик с помощью повторного вызова метода then\n            .then((response) => response.json())\n            // Стрелочная функция на вход принимает уже обработанное тело ответа\n            .then((todos) => {\n\n                // Обновляем состояние страницы\n                this.setState({\n                    todos: todos,\n\n                    // Сбрасываем флаг из loading\n                    isLoading: false\n                });\n            })\n            // Обработчик на тот случай, если асинхронный вызов по каким-то причином завершился с ошибкой,\n            // например, сервер не доступен\n            .catch(() => {\n                console.log('Произошла ошибка')\n            });\n    }\n\n    render() {\n        return (\n            <div className='todo-page'>\n                <h2>Todo page</h2>\n\n                {/* // if-else отрисовка */}\n                {this.state.isLoading && (\n                    <div className='loader'>\n                        Загрузка...\n                    </div>\n                ) || (\n                    // Метод map позволяет перебрать массив, и на ее основе сформировать новый массив\n                    // В данном случае формируем массив JSX-объектов. Метод map принимает функцию-обработчик,\n                    // которая принимает очередной элемент и индекс этого элемента \n                    this.state.todos.map((todo, index) => {\n                        return (\n                            // Компонента, которая добавляет элементу todo функционал удаления.\n                            // Внутрь JSX-объекта можно передать другой JSX-объект или список объектов.\n                            // Эти объекты будут записаны в props.children\n                            <Deletable\n                                title={todo.title}\n                                id={todo.id}\n                                // Передаем обработчик удаления\n                                deleteHandler={this.delete}\n\n                                // Подробнее про key-проп https://www.youtube.com/watch?v=OtAlPwW8DNU&t=409s\n                                key={todo.id}>\n                                    <div className='todo'>\n                                        <input\n                                            type='checkbox'\n                                            // Осуществляем контроль отображения компоненты\n                                            checked={todo.completed}\n                                            onChange={this.#handleCompletedChange.bind(this, index)}\n                                            // В завимисоти от состояния меняет CSS-стили\n                                        /> <span style={{ color: todo.completed ? 'green' : 'red' }}>{todo.title}</span>\n                                    </div>\n                            </Deletable>\n                        );\n                    })\n                )}\n            </div>\n        );\n\n    }\n\n    #handleCompletedChange(index) {\n        // Документация реакт по обновлению состояния списка https://react.dev/learn/updating-arrays-in-state\n        // Правильное обновление состояния сложных объект подразумевает, что мы должны изменить ссылку на сложный\n        // объект, иначе могут возникнуть различные проблемы с перерисовкой приложения. Обычно react-разработчики стараются\n        // оптимизировать количество перерисовок компонент, сравнивая предыдущие и текущие пропсы. Сравнение объектов в JS\n        // является поверхностным, то есть он сравнивает только ссылки на равенство. Если мы напрямую будем мутировать this.state.todos,\n        // и, например, у нас бы была оптимизированная компонента TodosList, которая на вход принимала бы массив todos, то приложение бы не обновлялось,\n        // даже если бы мы изменили хотя бы один объект в массиве. Но ссылка на сходный массив не изменилась, поэтому перерисовки интефейса не произойдет\n\n        // Правильным подходом является создание нового массива на основе данных сещствующего массива. Массивы в JS хранят ссылки на объекты.\n        // Вызов метода slice позволит создать новый массив на основе старого, путем копирования ссылок на объекты, то есть копирование здесь поверхностное,\n        // но с точки зрения работы с состоянием реакта мы все сделали правильно, поскольку мы не изменяем исходный объект, а создаем на его основе новый\n        // Такая здесь парадигма :)\n\n        // Очень хороший видеоролик, который показывает как правильно работать со сложным состоянием: https://www.youtube.com/watch?v=a2DkRBnp4ns\n\n        // Так же новые объекты массива создают методы map и filter. Их тоже можно использовать для создания нового объекта массива\n        // (в зависимости от задачи: отфильтровать массив или на основе существующего массива обработать каждый элемент и получить новый массив)\n        const updatedTodos = this.state.todos.slice();\n\n        // Здесь так же приведен объект, как правильно создавать новый объект на основе существующего.\n        // \"...\" это spread-оператор или деструктуризация, которая позволяет разложить все свойства объекта и на их основе сконструировать новый объект.\n        // Порядок при этом важен. ```completed: !updatedTodos[index].completed``` должно идти позже spread, иначе для нового объекта todo свойство completed\n        // будет взято из старого объекта\n        updatedTodos[index] = {\n            ...updatedTodos[index],\n            completed: !updatedTodos[index].completed\n        }\n\n        this.setState({\n            todos: updatedTodos\n        });\n    }\n\n    #handlerTodoDelete(id) {\n        // Реализуем удаление элемента с помощью метода filter, который возвращает новый массив, состоящий из элементов,\n        // прошедших фильтрацию\n        const updatedTodos = this.state.todos.filter((todo) => {\n            return todo.id !== id;\n        })\n\n        this.setState({\n            todos: updatedTodos\n        });\n    }\n}"],"mappings":"wRAAA,OAASA,SAAS,KAAQ,OAAO,CAEjC;AACA,OAASC,SAAS,KAAQ,mCAAmC,CAE7D;AACA,MAAO,aAAa,CAEpB;AAAA,OAAAC,GAAA,IAAAC,IAAA,CAAAC,IAAA,IAAAC,KAAA,6BAAAC,sBAAA,cAAAC,0BAAA,8BAAAC,kBAAA,cAAAD,0BAAA,sBACA,MAAO,MAAM,CAAAE,QAAQ,QAAS,CAAAT,SAAU,CACpCU,WAAWA,CAACC,KAAK,CAAE,CACf,KAAK,CAACA,KAAK,CAAC,CAEZ;AAAAC,MAAA,CAAAC,cAAA,MAAAL,kBAAA,EAAAM,KAAA,CAAAC,mBAAA,GAAAH,MAAA,CAAAC,cAAA,MAAAP,sBAAA,EAAAQ,KAAA,CAAAE,uBAAA,GAUJ;AACA;AACA;AACA;AAAA,KACAC,MAAM,CAAGC,2BAAA,KAAI,CAAAV,kBAAA,EAAAA,kBAAA,EAAoBW,IAAI,CAAC,IAAI,CAAC,CAbvC,IAAI,CAACC,KAAK,CAAG,CACT;AACAC,KAAK,CAAE,EAAE,CAET;AACAC,SAAS,CAAE,IACf,CAAC,CACL,CAQA;AACAC,iBAAiBA,CAAA,CAAG,CAChB;AACA;AACAC,KAAK,CAAC,4CAA4C,CAC9C;AACA;AAAA,CACCC,IAAI,CAAEC,QAAQ,EAAKA,QAAQ,CAACC,IAAI,CAAC,CAAC,CACnC;AAAA,CACCF,IAAI,CAAEJ,KAAK,EAAK,CAEb;AACA,IAAI,CAACO,QAAQ,CAAC,CACVP,KAAK,CAAEA,KAAK,CAEZ;AACAC,SAAS,CAAE,KACf,CAAC,CAAC,CACN,CAAC,CACD;AACA;AAAA,CACCO,KAAK,CAAC,IAAM,CACTC,OAAO,CAACC,GAAG,CAAC,kBAAkB,CAAC,CACnC,CAAC,CAAC,CACV,CAEAC,MAAMA,CAAA,CAAG,CACL,mBACI3B,KAAA,QAAK4B,SAAS,CAAC,WAAW,CAAAC,QAAA,eACtB/B,IAAA,OAAA+B,QAAA,CAAI,WAAS,CAAI,CAAC,CAGjB,IAAI,CAACd,KAAK,CAACE,SAAS,eACjBnB,IAAA,QAAK8B,SAAS,CAAC,QAAQ,CAAAC,QAAA,CAAC,qDAExB,CAAK,CACR,EACG;AACA;AACA;AACA,IAAI,CAACd,KAAK,CAACC,KAAK,CAACc,GAAG,CAAC,CAACC,IAAI,CAAEC,KAAK,GAAK,CAClC,oBACI;AACA;AACA;AACAlC,IAAA,CAACF,SAAS,EACNqC,KAAK,CAAEF,IAAI,CAACE,KAAM,CAClBC,EAAE,CAAEH,IAAI,CAACG,EACT;AAAA,CACAC,aAAa,CAAE,IAAI,CAACvB,MAEpB;AAAA,CAAAiB,QAAA,cAEI7B,KAAA,QAAK4B,SAAS,CAAC,MAAM,CAAAC,QAAA,eACjB/B,IAAA,UACIsC,IAAI,CAAC,UACL;AAAA,CACAC,OAAO,CAAEN,IAAI,CAACO,SAAU,CACxBC,QAAQ,CAAE1B,2BAAA,KAAI,CAAAZ,sBAAA,EAAAA,sBAAA,EAAwBa,IAAI,CAAC,IAAI,CAAEkB,KAAK,CACtD;AAAA,CACH,CAAC,IAAC,cAAAlC,IAAA,SAAM0C,KAAK,CAAE,CAAEC,KAAK,CAAEV,IAAI,CAACO,SAAS,CAAG,OAAO,CAAG,KAAM,CAAE,CAAAT,QAAA,CAAEE,IAAI,CAACE,KAAK,CAAO,CAAC,EAC/E,CAAC,EATLF,IAAI,CAACG,EAUH,CAAC,EAEpB,CAAC,CACJ,EACA,CAAC,CAGd,CA+CJ,CAAC,SAAAvB,wBA7C0BqB,KAAK,CAAE,CAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA,KAAM,CAAAU,YAAY,CAAG,IAAI,CAAC3B,KAAK,CAACC,KAAK,CAAC2B,KAAK,CAAC,CAAC,CAE7C;AACA;AACA;AACA;AACAD,YAAY,CAACV,KAAK,CAAC,CAAG,CAClB,GAAGU,YAAY,CAACV,KAAK,CAAC,CACtBM,SAAS,CAAE,CAACI,YAAY,CAACV,KAAK,CAAC,CAACM,SACpC,CAAC,CAED,IAAI,CAACf,QAAQ,CAAC,CACVP,KAAK,CAAE0B,YACX,CAAC,CAAC,CACN,CAAC,SAAAhC,oBAEkBwB,EAAE,CAAE,CACnB;AACA;AACA,KAAM,CAAAQ,YAAY,CAAG,IAAI,CAAC3B,KAAK,CAACC,KAAK,CAAC4B,MAAM,CAAEb,IAAI,EAAK,CACnD,MAAO,CAAAA,IAAI,CAACG,EAAE,GAAKA,EAAE,CACzB,CAAC,CAAC,CAEF,IAAI,CAACX,QAAQ,CAAC,CACVP,KAAK,CAAE0B,YACX,CAAC,CAAC,CACN","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}